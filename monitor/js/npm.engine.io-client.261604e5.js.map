{"version":3,"sources":["webpack:///./node_modules/engine.io-client/build/esm/transports/websocket.js","webpack:///./node_modules/engine.io-client/build/esm/globalThis.browser.js","webpack:///./node_modules/engine.io-client/build/esm/transport.js","webpack:///./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js","webpack:///./node_modules/engine.io-client/build/esm/transports/polling.js","webpack:///./node_modules/engine.io-client/build/esm/transports/polling-xhr.js","webpack:///./node_modules/engine.io-client/build/esm/transports/index.js","webpack:///./node_modules/engine.io-client/build/esm/socket.js","webpack:///./node_modules/engine.io-client/build/esm/index.js","webpack:///./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js","webpack:///./node_modules/engine.io-client/build/esm/util.js"],"names":["isReactNative","navigator","product","toLowerCase","WS","opts","super","this","supportsBinary","forceBase64","check","uri","protocols","extraHeaders","headers","ws","err","emit","binaryType","socket","addEventListeners","onopen","autoUnref","_socket","unref","onOpen","onclose","onClose","bind","onmessage","ev","onData","data","onerror","e","onError","packets","writable","i","length","packet","lastPacket","options","compress","perMessageDeflate","len","Buffer","byteLength","threshold","send","setTimeoutFn","close","query","schema","secure","port","Number","timestampRequests","timestampParam","b64","encodedQuery","encode","ipv6","hostname","indexOf","path","name","prototype","self","window","Function","Transport","readyState","msg","desc","Error","type","description","doOpen","doClose","write","onPacket","xdomain","XMLHttpRequest","concat","join","arguments","polling","poll","onPause","pause","total","once","doPoll","callback","forEach","doWrite","sid","empty","hasXHR2","xhr","responseType","location","isSSL","protocol","xd","xs","Object","assign","fn","req","request","method","on","pollXhr","async","undefined","create","xscheme","open","setDisableHeaderCheck","hasOwnProperty","setRequestHeader","withCredentials","requestTimeout","timeout","onreadystatechange","status","onLoad","document","index","requestsCount","requests","cleanup","onSuccess","fromError","abort","responseText","attachEvent","unloadHandler","addEventListener","terminationEvent","transports","websocket","host","writeBuffer","prevBufferLen","agent","upgrade","rememberUpgrade","rejectUnauthorized","transportOptions","closeOnBeforeunload","replace","decode","id","upgrades","pingInterval","pingTimeout","pingTimeoutTimer","transport","removeAllListeners","offlineEventListener","clone","EIO","priorWebsocketSuccess","emitReserved","createTransport","shift","setTransport","onDrain","failed","onTransportOpen","upgrading","flush","freezeTransport","error","onTransportClose","onupgrade","to","removeListener","off","l","probe","onHandshake","JSON","parse","resetPingTimeout","sendPacket","code","filterUpgrades","clearTimeoutFn","splice","push","cleanupAndClose","waitForUpgrade","reason","removeEventListener","filteredUpgrades","j","obj","o","nextTick","isPromiseAvailable","Promise","resolve","cb","then","WebSocket","MozWebSocket","usingBrowserWebSocket","defaultBinaryType","pick","attr","reduce","acc","k","NATIVE_SET_TIMEOUT","setTimeout","NATIVE_CLEAR_TIMEOUT","clearTimeout","installTimerFunctions","useNativeTimers"],"mappings":"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","file":"js/npm.engine.io-client.261604e5.js","sourcesContent":["import { Transport } from \"../transport.js\";\nimport parseqs from \"parseqs\";\nimport yeast from \"yeast\";\nimport { pick } from \"../util.js\";\nimport { defaultBinaryType, nextTick, usingBrowserWebSocket, WebSocket } from \"./websocket-constructor.js\";\nimport { encodePacket } from \"engine.io-parser\";\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nexport class WS extends Transport {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @api {Object} connection options\n     * @api public\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Transport name.\n     *\n     * @api public\n     */\n    get name() {\n        return \"websocket\";\n    }\n    /**\n     * Opens socket.\n     *\n     * @api private\n     */\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                usingBrowserWebSocket && !isReactNative\n                    ? protocols\n                        ? new WebSocket(uri, protocols)\n                        : new WebSocket(uri)\n                    : new WebSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emit(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType || defaultBinaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @api private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = this.onClose.bind(this);\n        this.ws.onmessage = ev => this.onData(ev.data);\n        this.ws.onerror = e => this.onError(\"websocket error\", e);\n    }\n    /**\n     * Writes data to socket.\n     *\n     * @param {Array} array of packets.\n     * @api private\n     */\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            encodePacket(packet, this.supportsBinary, data => {\n                // always create a new object (GH-437)\n                const opts = {};\n                if (!usingBrowserWebSocket) {\n                    if (packet.options) {\n                        opts.compress = packet.options.compress;\n                    }\n                    if (this.opts.perMessageDeflate) {\n                        const len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                            opts.compress = false;\n                        }\n                    }\n                }\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                    else {\n                        this.ws.send(data, opts);\n                    }\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emit(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    /**\n     * Closes socket.\n     *\n     * @api private\n     */\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @api private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        let port = \"\";\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = yeast();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        const encodedQuery = parseqs.encode(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @api public\n     */\n    check() {\n        return (!!WebSocket &&\n            !(\"__initialize\" in WebSocket && this.name === WS.prototype.name));\n    }\n}\n","export default (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n","import { decodePacket } from \"engine.io-parser\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions } from \"./util.js\";\nexport class Transport extends Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} options.\n     * @api private\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.readyState = \"\";\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} str\n     * @return {Transport} for chaining\n     * @api protected\n     */\n    onError(msg, desc) {\n        const err = new Error(msg);\n        // @ts-ignore\n        err.type = \"TransportError\";\n        // @ts-ignore\n        err.description = desc;\n        super.emit(\"error\", err);\n        return this;\n    }\n    /**\n     * Opens the transport.\n     *\n     * @api public\n     */\n    open() {\n        if (\"closed\" === this.readyState || \"\" === this.readyState) {\n            this.readyState = \"opening\";\n            this.doOpen();\n        }\n        return this;\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api public\n     */\n    close() {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     * @api public\n     */\n    send(packets) {\n        if (\"open\" === this.readyState) {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @api protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emit(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @api protected\n     */\n    onData(data) {\n        const packet = decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @api protected\n     */\n    onPacket(packet) {\n        super.emit(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @api protected\n     */\n    onClose() {\n        this.readyState = \"closed\";\n        super.emit(\"close\");\n    }\n}\n","// browser shim for xmlhttprequest module\nimport hasCORS from \"has-cors\";\nimport globalThis from \"../globalThis.js\";\nexport default function (opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\n","import { Transport } from \"../transport.js\";\nimport yeast from \"yeast\";\nimport parseqs from \"parseqs\";\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\nexport class Polling extends Transport {\n    constructor() {\n        super(...arguments);\n        this.polling = false;\n    }\n    /**\n     * Transport name.\n     */\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @api private\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} callback upon buffers are flushed and transport is paused\n     * @api private\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @api public\n     */\n    poll() {\n        this.polling = true;\n        this.doPoll();\n        this.emit(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @api private\n     */\n    onData(data) {\n        const callback = packet => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose();\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        decodePayload(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emit(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @api private\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} data packets\n     * @param {Function} drain callback\n     * @api private\n     */\n    write(packets) {\n        this.writable = false;\n        encodePayload(packets, data => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emit(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @api private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        let port = \"\";\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = yeast();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                (\"http\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        const encodedQuery = parseqs.encode(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n}\n","/* global attachEvent */\nimport XMLHttpRequest from \"./xmlhttprequest.js\";\nimport globalThis from \"../globalThis.js\";\nimport { installTimerFunctions, pick } from \"../util.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { Polling } from \"./polling.js\";\n/**\n * Empty function\n */\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new XMLHttpRequest({\n        xdomain: false\n    });\n    return null != xhr.responseType;\n})();\nexport class XHR extends Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @api public\n     */\n    constructor(opts) {\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n            this.xs = opts.secure !== isSSL;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @api private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @api private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", err => {\n            this.onError(\"xhr post error\", err);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @api private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", err => {\n            this.onError(\"xhr poll error\", err);\n        });\n        this.pollXhr = req;\n    }\n}\nexport class Request extends Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @api public\n     */\n    constructor(uri, opts) {\n        super();\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.async = false !== opts.async;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @api private\n     */\n    create() {\n        const opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        opts.xscheme = !!this.opts.xs;\n        const xhr = (this.xhr = new XMLHttpRequest(opts));\n        try {\n            xhr.open(this.method, this.uri, this.async);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon successful response.\n     *\n     * @api private\n     */\n    onSuccess() {\n        this.emit(\"success\");\n        this.cleanup();\n    }\n    /**\n     * Called if we have data.\n     *\n     * @api private\n     */\n    onData(data) {\n        this.emit(\"data\", data);\n        this.onSuccess();\n    }\n    /**\n     * Called upon error.\n     *\n     * @api private\n     */\n    onError(err) {\n        this.emit(\"error\", err);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @api private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @api private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.onData(data);\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @api public\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n","import { XHR } from \"./polling-xhr.js\";\nimport { WS } from \"./websocket.js\";\nexport const transports = {\n    websocket: WS,\n    polling: XHR\n};\n","import { transports } from \"./transports/index.js\";\nimport { installTimerFunctions } from \"./util.js\";\nimport parseqs from \"parseqs\";\nimport parseuri from \"parseuri\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { protocol } from \"engine.io-parser\";\nexport class Socket extends Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri or options\n     * @param {Object} opts - options\n     * @api public\n     */\n    constructor(uri, opts = {}) {\n        super();\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = parseuri(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = parseuri(opts.host).host;\n        }\n        installTimerFunctions(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\"polling\", \"websocket\"];\n        this.readyState = \"\";\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024\n            },\n            transportOptions: {},\n            closeOnBeforeunload: true\n        }, opts);\n        this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\";\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = parseqs.decode(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                addEventListener(\"beforeunload\", () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                }, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\");\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} transport name\n     * @return {Transport}\n     * @api private\n     */\n    createTransport(name) {\n        const query = clone(this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port\n        });\n        return new transports[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @api private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @api private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", () => {\n            this.onClose(\"transport close\");\n        });\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} transport name\n     * @api private\n     */\n    probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", msg => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = err => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        transport.open();\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @api private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState &&\n            this.opts.upgrade &&\n            this.transport.pause) {\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @api private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @api private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @api private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @api private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @api private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            this.transport.send(this.writeBuffer);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = this.writeBuffer.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} message.\n     * @param {Function} callback function.\n     * @param {Object} options.\n     * @return {Socket} for chaining.\n     * @api public\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @api private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     *\n     * @api public\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @api private\n     */\n    onError(err) {\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @api private\n     */\n    onClose(reason, desc) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, desc);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} server upgrades\n     * @api private\n     *\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nSocket.protocol = protocol;\nfunction clone(obj) {\n    const o = {};\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            o[i] = obj[i];\n        }\n    }\n    return o;\n}\n","import { Socket } from \"./socket.js\";\nexport { Socket };\nexport const protocol = Socket.protocol;\nexport { Transport } from \"./transport.js\";\nexport { transports } from \"./transports/index.js\";\nexport { installTimerFunctions } from \"./util.js\";\n","import globalThis from \"../globalThis.js\";\nexport const nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return cb => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nexport const WebSocket = globalThis.WebSocket || globalThis.MozWebSocket;\nexport const usingBrowserWebSocket = true;\nexport const defaultBinaryType = \"arraybuffer\";\n","import globalThis from \"./globalThis.js\";\nexport function pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = clearTimeout;\nexport function installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);\n    }\n    else {\n        obj.setTimeoutFn = setTimeout.bind(globalThis);\n        obj.clearTimeoutFn = clearTimeout.bind(globalThis);\n    }\n}\n"],"sourceRoot":""}