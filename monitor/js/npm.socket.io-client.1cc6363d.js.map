{"version":3,"sources":["webpack:///./node_modules/socket.io-client/build/esm/url.js","webpack:///./node_modules/socket.io-client/build/esm/on.js","webpack:///./node_modules/socket.io-client/build/esm/socket.js","webpack:///./node_modules/socket.io-client/build/esm/manager.js","webpack:///./node_modules/socket.io-client/build/esm/index.js"],"names":["url","uri","path","loc","obj","location","protocol","host","charAt","test","port","ipv6","indexOf","id","href","on","ev","fn","off","RESERVED_EVENTS","Object","freeze","connect","connect_error","disconnect","disconnecting","newListener","removeListener","io","nsp","opts","super","this","connected","disconnected","receiveBuffer","sendBuffer","ids","acks","flags","auth","_autoConnect","open","subs","onopen","bind","onpacket","onerror","onclose","subEvents","_readyState","args","unshift","emit","apply","hasOwnProperty","Error","packet","type","EVENT","data","options","compress","length","ack","pop","_registerAckCallback","isTransportWritable","engine","transport","writable","discardPacket","volatile","push","timeout","undefined","timer","setTimeoutFn","i","splice","call","clearTimeoutFn","_packet","CONNECT","err","emitReserved","reason","sameNamespace","sid","onconnect","onevent","BINARY_EVENT","ACK","onack","BINARY_ACK","DISCONNECT","ondisconnect","CONNECT_ERROR","destroy","message","emitEvent","_anyListeners","listeners","slice","listener","self","sent","emitBuffered","forEach","subDestroy","_a","nsps","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","min","max","jitter","_parser","parser","encoder","Encoder","decoder","Decoder","autoConnect","v","arguments","_reconnection","_reconnectionAttempts","_reconnectionDelay","setMin","_randomizationFactor","setJitter","_reconnectionDelayMax","setMax","_timeout","_reconnecting","attempts","reconnect","socket","skipReconnect","openSubDestroy","errorSub","cleanup","maybeReconnectOnOpen","close","autoUnref","unref","clearTimeout","onping","ondata","ondecoded","add","keys","active","_close","encodedPackets","encode","write","reset","delay","duration","onreconnect","attempt","cache","lookup","parsed","source","newConnection","forceNew","multiplex","query","queryKey","assign","Manager","Socket"],"mappings":"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","file":"js/npm.socket.io-client.1cc6363d.js","sourcesContent":["import parseuri from \"parseuri\";\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nexport function url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = parseuri(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n","export function on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n","import { PacketType } from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\nexport class Socket extends Emitter {\n    /**\n     * `Socket` constructor.\n     *\n     * @public\n     */\n    constructor(io, nsp, opts) {\n        super();\n        this.connected = false;\n        this.disconnected = true;\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on(io, \"open\", this.onopen.bind(this)),\n            on(io, \"packet\", this.onpacket.bind(this)),\n            on(io, \"error\", this.onerror.bind(this)),\n            on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @public\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for connect()\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * @return self\n     * @public\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @return self\n     * @public\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        const packet = {\n            type: PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n        }\n        else if (this.connected) {\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        const timeout = this.flags.timeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks[id] = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, [null, ...args]);\n        };\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this.packet({ type: PacketType.CONNECT, data });\n            });\n        }\n        else {\n            this.packet({ type: PacketType.CONNECT, data: this.auth });\n        }\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @private\n     */\n    onclose(reason) {\n        this.connected = false;\n        this.disconnected = true;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    const id = packet.data.sid;\n                    this.onconnect(id);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.ACK:\n                this.onack(packet);\n                break;\n            case PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id) {\n        this.id = id;\n        this.connected = true;\n        this.disconnected = false;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => this.packet(packet));\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually.\n     *\n     * @return self\n     * @public\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for disconnect()\n     *\n     * @return self\n     * @public\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     * @public\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @returns self\n     * @public\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * ```\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     * ```\n     *\n     * @returns self\n     * @public\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @param listener\n     * @public\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     * @public\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @param listener\n     * @public\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     *\n     * @public\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n}\n","import { Socket as Engine, installTimerFunctions, } from \"engine.io-client\";\nimport { Socket } from \"./socket.js\";\nimport * as parser from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport Backoff from \"backo2\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\nexport class Manager extends Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new Engine(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = on(socket, \"error\", (err) => {\n            self.cleanup();\n            self._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                socket.close();\n                // @ts-ignore\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        this.decoder.add(data);\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        this.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason) {\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n","import { url } from \"./url.js\";\nimport { Manager } from \"./manager.js\";\nimport { Socket } from \"./socket.js\";\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager,\n    Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nexport { protocol } from \"socket.io-parser\";\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\nexport { Manager, Socket, lookup as io, lookup as connect, lookup as default, };\n"],"sourceRoot":""}